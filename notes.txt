Για παράδειγμα, ας υποθέσουμε πως V = { {u, q}, {-u,r}, {-r, -q, -z} }
και θέλουμε να “ξεχάσουμε” μόνο την μεταβλητή u (δηλ., P = {u}).

Για να το κάνουμε αυτό κατασκευάζουμε από την V
την βάση γνώσης V[u|T] αντικαθιστώντας το u με true,
και την βάση γνώσης V[u|F] αντικαθιστώντας το u με false.

Συγκεκριμένα,
V[u|T] = { {Τ, q}, {-Τ,r}, {-r, -q, -z} } = { {r}, {-r,-q,-z} }
V[u|F] = { {F, q}, {-F,r}, {-r, -q, -z} } = { {q}, {-r,-q,-z} }

Στην συνέχεια παίρνουμε την διάζευξη του V[u|T] με το V[u|F],
και την μετατρέπουμε σε CNF. Αυτή θα είναι η τιμή του forget(V,P).
Συγκεκριμένα, forget(V,{u}) = { {r,q} {-r,-q,-z} }.

Τώρα, αν έχουμε πάνω από μια μεταβλητή στο P (πχ P = {u, z}),
θα πρέπει να κατασκευάσουμε τα σύνολα V[P|I] για κάθε συνδυασμό
τιμών αληθείας I των μεταβλητών του P, να πάρουμε την διάζευξή τους
(π.χ.  V[uz|TT]  ∨ V[uz|TF] ∨ V[uz|FT] ∨ V[uz|FF]), και να
την μετατρέψουμε σε CNF.

Δίνω τώρα τον αλγόριθμο.

Στον αλγόριθμο υποθέτω ότι η βάση γνώσης Κ, η νέα πληροφορία Α, και
η πρόταση Β που θέλουμε να ελέγξουμε μετά την αναθεώρηση
του Κ ως προς Α είναι σε CNF.

Επίσης, για να ορίσω την διάταξη των atoms, θα χρησιμοποιήσω βάρη
(πχ, για να δηλώσω πως p<q, ορίζω w(p)=1 και w(q) = 2).

Στο παράδειγμα για την εφαρμογή του αλγορίθμου παίρνω,
Κ = { {q, z}, {p, -q, r, -z}, {-q, z}, {q, u}, {-z, -u}, {-r,-u} }
A = { {-q, -z} }
B = { {-u}, {q} }
w(p) = w(z) = 1.
w(q) = w(r) = 2.
w(u) = 3.

ΑΛΓΟΡΙΘΜΟΣ:
INPUT: K, A, B και βάρη w για τα atoms.
OUTPUT: "Yes" αν Κ*Α |= Β, αλλιώς "Νο".

Βήμα 1: Αν το Κ είναι unsatisfiable, [ επέστρεψε “Yes” εφόσον το
                Α∪-B είναι unsatisfiable, αλλιώς αλλιώς επέστρεψε "No”].

Βήμα 1.5: Κατασκεύασε την βάση γνώσης Κ’ = forget(K, {x: x μεταβλητή που εμφανίζεται στο Α}).
                  Στο παράδειγμα, Κ’ = { {-u}, {p,r} }.

Βήμα 2: Αν η γλώσσα του Α δεν έχει κοινές μεταβλητές με την Β, τότε
                [επέστρεψε "Yes" αν το Κ'∪-B είναι unsatisfiable, αλλιώς επέστρεψε "No”].

Βήμα 3:         Κατασκεύασε το σύνολο Q(0) όλων των μοντέλων του Α, χρησιμοποιώντας
                MONO τις μεταβλητές που εμφανίζονται στο Α. Στο παράδειγμά μας,
                Q(0) = { {q, -z}, {-q, z}, {-q,-z} }.
                ΠΡΟΣΟΧΗ: στα μοντέλα, ένα σύνολο literals αναπαριστά ΣΥΖΕΥΞΗ. Αντίθετα,
                στα Κ, Α, Β, ένα σύνολο literlas αναπαριστά ΔΙΑΖΕΥΞΗ.

Βήμα 4:         i:=-1.

Βήμα 5:         ΕΠΑΝΕΛΑΒΕ
                        i := i+1
                        Κατασκεύασε το σύνολο Q(i) που προκύπτει από το σύνολο Q(0)
                        αλλάζοντας σε κάθε μοντέλο του Q(0) ακριβώς i τιμές στις μεταβλητές.
                        Για παράδειγμα, Q(1) = { {q z}, {-q, -z}, {q, -z}, {-q, z} }.
                        Κατασκεύασε το σύνολο S(i) = { Μ ∈ Q:  M & K είναι ικανοποιήσιμο }
                ΕΝΟΣΩ [ S(i) είναι κενό ]
                Στο παράδειγμα, ο προηγούμενος βρόχος σταματάει για i=1, S(i) = { {q, z} }.

Βήμα 6:         Υπολόγισε το σύνολο Τ = { (M,D):   M ∈ Q(0) και D σύνολο i μεταβλητών, τέτοια ώστε
                αλλάζοντας στο Μ τις τιμές των μεταβλητών στο D, καταλήγουμε σε σύνολο Μ’ ∈ S(i) }.
                Στο παράδειγμα, T = { ({q,-z}, {z}), ({-q,z}, {q}) }.

Βήμα 7:         Υπολόγισε το σύνολο W = { D:  D είναι σύνολο μεταβλητών και για κάποιο M ∈ Q(0), (M,D) ∈ T }.
                Στο παράδειγμα, W = { {z}, {q} }.

Βήμα 8:         Υπολόγισε το σύνολο E = { D: D είναι καλύτερο σύνολο του W με βάση τα βάρη w(x) }.
                Στο παράδειγμα, E = { {z} }.

Βήμα 9:         Υπολόγισε το σύνολο R = { M: (M,D) ∈ T, και το D ∈ E }.
                Στο παράδειγμα, R = { {q,-z} }.

Βήμα 10:  Κατασκεύασε την βάση γνώσης H = Μ_1 ∨ Μ_2 . . . ∨ Μ_n σε CNF,
                   όπου M_i ∈ R. Επιπλέον, κατασκεύασε το -B σε CNF.
                   Στο παράδειγμα, Η = { {q}, {-z} }, και -Β = { {u,-q} }.

Βήμα 11:   Αν Η ∪ Κ' ∪ -B είναι ικανοποιήσιμο, τότε επέστρεψε “Νο”,
                   αλλιώς επέστρεψε “Yes”.
                   Στο παράδειγμα Η ∪ Κ' ∪ -B = { {q}, {-z}, {-u}, {p,r}, {u,-q} }
                   το οποίο είναι unsatisfiable, οπότε ο αλγόριθμος επιστρέφει “Yes”.

Προφανώς ο αλγόριθμος μπορεί να βελτιωθεί. Ωστόσο θα πρέπει
πρώτα να καταλάβεις την βασική του λειτουργία και μετά θα σου
πω πως μπορούν να γίνουν βελτιώσεις.